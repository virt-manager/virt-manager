# -*- python -*-
#
# Copyright (C) 2006 Red Hat, Inc.
# Copyright (C) 2006 Daniel P. Berrange <berrange@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

from os import getcwd
import os.path
import sys

import locale
import gettext
import logging
import traceback

gettext_app = "virt-manager"
gettext_dir = "::GETTEXTDIR::"

locale.setlocale(locale.LC_ALL, '')
gettext.install(gettext_app, gettext_dir)
gettext.bindtextdomain(gettext_app, gettext_dir)

# set up logging
vm_dir = os.path.expanduser("~/.virt-manager")
if not os.access(vm_dir,os.W_OK):
    try:
        os.mkdir(vm_dir)
    except IOError, e:
        raise RuntimeError, "Could not create %d directory: " % vm_dir, e

# XXX should we get logging level from gconf, or command line args ?
logging.basicConfig(level=logging.DEBUG,
                    format="%(asctime)s %(levelname)-8s %(message)s",
                    datefmt="%a, %d %b %Y %H:%M:%S",
                    filename="%s/virt-manager.log" % vm_dir,
                    filemode='w')

# Urgh, pygtk merely logs a warning when failing to open
# the X11 display connection, and lets everything carry
# on as if all were fine. Ultimately bad stuff happens,
# so lets catch it here & get the hell out...
import warnings
warnings.filterwarnings('error', module='gtk')
try:
    import gtk
except Warning, e:
    # ...the risk is we catch too much though
    # Damned if we do, damned if we dont :-)(
    print _("Unable to initialize GTK: ") + str(e)
    sys.exit(1)
warnings.resetwarnings()

import gtk
gtk.gdk.threads_init()

import dbus
import dbus.glib
dbus.glib.threads_init()
import dbus.service

from optparse import OptionParser, OptionValueError

appname = "::PACKAGE::"
appversion = "::VERSION::"
gconf_dir = "/apps/" + appname
asset_dir = "::ASSETDIR::"
glade_dir = asset_dir
icon_dir = asset_dir + "/pixmaps"
pylib_dir = "::PYLIBDIR::"
pyarchlib_dir = "::PYARCHLIBDIR::"
data_dir = "::DATADIR::"

# Hack for dev purposes
if os.path.exists(os.getcwd() + "/src/vmm-about.glade"):
    glade_dir = os.getcwd() + "/src"
if os.path.exists(os.getcwd() + "/pixmaps/icon_run.png"):
    icon_dir = os.getcwd() + "/pixmaps"
if os.path.exists(os.getcwd() + "../gnome/help/virt-manager/C/virt-manager.xml"):
    data_dir = os.getcwd() + "../"

if os.path.exists(os.getcwd() + "/src/virt-manager.py"):
    sys.path.insert(0, os.getcwd() + "/src/graphWidgets/.libs")
elif os.path.exists(os.getcwd() + "/build/src/virt-manager.py"):
    sys.path.insert(0, os.getcwd() + "/src")
    sys.path.insert(0, os.getcwd() + "/build/src/graphWidgets/.libs")
else:
    sys.path.insert(0, pylib_dir)
    sys.path.insert(0, pyarchlib_dir)

from virtManager.config import vmmConfig
from virtManager.engine import vmmEngine
from virtManager.remote import vmmRemote

gtk.window_set_default_icon_from_file(icon_dir + "/" + appname + "-icon.svg")

# maps --show-* to engine (ie local instance) methods
def show_engine(engine, show, uri, uuid):
    if show=='creator':
        engine.show_create(uri)
    elif show=='editor':
        engine.show_details_config(uri, uuid)
    elif show=='performance':
        engine.show_details_performance(uri, uuid)
    elif show=='console':
        engine.show_console(uri, uuid)
    elif show=='summary' or uri:
        engine.show_manager(uri)
    else:
        tryuri = None
        if os.path.exists("/var/lib/xend") and os.path.exists("/proc/xen"):
            tryuri = "xen"
        elif os.path.exists("/usr/bin/qemu"):
            if os.getuid() == 0:
                tryuri = "qemu:///system"
            else:
                tryuri = "qemu:///session"
        if tryuri is not None:
            try:
                conn = engine.get_connection(tryuri)
                engine.show_manager(tryuri)
            except:
                (type, value, stacktrace) = sys.exc_info ()

                # Detailed error message, in English so it can be Googled.
                details = \
                        ("Unable to open auto-open connection to hypervisor URI '%s':\n" %
                         str(tryuri)) + \
                         str(type) + " " + str(value) + "\n" + \
                         traceback.format_exc (stacktrace)
                logging.warning(details)

                tryuri = None
        if tryuri is None:
            engine.show_connect()

# maps --show-* to remote manager (ie dbus call) methods
def show_remote(managerObj, show, uri, uuid):
    if show=='creator':
        managerObj.show_domain_creator(uri)
    elif show=='editor':
        managerObj.show_domain_editor(uri, uuid)
    elif show=='performance':
        managerObj.show_domain_performance(uri, uuid)
    elif show=='console':
        managerObj.show_domain_console(uri, uuid)
    elif show=='summary' or uri:
        managerObj.show_host_summary(uri)
    else:
        managerObj.show_connect()

# Generic OptionParser callback for all --show-* options
# This routine stores UUID to options.uuid for all --show-* options 
# where is metavar="UUID" and also sets options.show
def opt_show_cb(option, opt_str, value, parser):
    if option.metavar=="UUID":
        setattr(parser.values, "uuid", value)        
    s = str(option)
    show = s[s.rindex('-')+1:]
    setattr(parser.values, "show", show)

# Run me!
def main():
    optParser = OptionParser()
    optParser.add_option("--profile", dest="profile", help="Generate runtime performance profile stats", metavar="FILE")
    optParser.set_defaults(uuid=None)
    optParser.add_option("-c", "--connect", dest="uri", 
        help="Connect to hypervisor at URI", metavar="URI")
    optParser.add_option("--no-dbus", action="store_true", dest="nodbus", 
        help="Disable DBus service for controlling UI")
    optParser.add_option("--show-domain-creator", action="callback", 
        callback=opt_show_cb, dest="show", help="Create a new virtual machine")
    optParser.add_option("--show-domain-editor",  type="string", metavar="UUID",
        action="callback", callback=opt_show_cb, help="Edit a domain configuration")
    optParser.add_option("--show-domain-performance", type="string", metavar="UUID", 
        action="callback", callback=opt_show_cb, help="Show a domain performance")
    optParser.add_option("--show-domain-console", type="string", metavar="UUID",
        action="callback", callback=opt_show_cb, help="Show a domain console")
    optParser.add_option("--show-host-summary", action="callback", 
       callback=opt_show_cb, help="Show a host summary")

    (options, args) = optParser.parse_args()

    if options.show and options.uri==None:
        raise OptionValueError("can't use --show-* options without --connect")

    config = vmmConfig(appname, appversion, gconf_dir, glade_dir, icon_dir, data_dir)
    engine = vmmEngine(config)
    if not(options.nodbus) and not( (os.getenv("DBUS_SESSION_BUS_ADDRESS") is None ) and ( os.getenv("DBUS_STARTER_ADDRESS") is None ) ):
        try:
            bus = None
            if os.getenv("DBUS_STARTER_ADDRESS") is None:
            	bus = dbus.SessionBus()
  	    else:
		bus = dbus.StarterBus()

            dbusProxy = bus.get_object("org.freedesktop.DBus", "/org/freedesktop/DBus")
            dbusObj = dbus.Interface(dbusProxy, "org.freedesktop.DBus")

            if dbusObj.NameHasOwner("com.redhat.virt.manager"):
                # We're already running, so just talk to existing process
                managerProxy = bus.get_object("com.redhat.virt.manager", "/com/redhat/virt/manager")
                managerObj = dbus.Interface(managerProxy, "com.redhat.virt.manager")

                show_remote(managerObj, options.show, options.uri, options.uuid)

                # yes, we exit completely now - remote service is in charge
                return
            else:
                # Grab the service to allow others to talk to us later
                name = dbus.service.BusName("com.redhat.virt.manager", bus=bus)
                remote = vmmRemote(engine, name)
        except:
            # Something went wrong doing dbus setup, just ignor & carry on
            logging.warning("Could not connection to session bus, disabling DBus service " + \
                            str(sys.exc_info()[0]) + " " + str(sys.exc_info()[1]))

    # Finally start the app for real
    show_engine(engine, options.show, options.uri, options.uuid)
    if options.profile != None:
        import hotshot
        prof = hotshot.Profile(options.profile)
        gtk.gdk.threads_enter()
        prof.runcall(gtk.main)
        gtk.gdk.threads_leave()
        prof.close()
    else:
        gtk.gdk.threads_enter()
        gtk.main()
        gtk.gdk.threads_leave()

if __name__ == "__main__":
    main()
